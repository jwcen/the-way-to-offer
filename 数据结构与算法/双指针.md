[TOC]

# 同向双指针

## 209. 长度最小的子数组

思路：双指针的滑动窗口

> left 移动时子数组的和不断变小，直到满足要求，满足单调性。

时间复杂度：O(n)

> 非`O(n^2)`，二重循环的复杂度可以理解为`left+=1` 的次数以及 `right += 1`的次数，至多加到`n`

go:

```go
func minSubArrayLen(target int, nums []int) int {
    n := len(nums) 
    left := 0
    sum := 0  
    ans := n + 1 
    for right, num := range nums {  // 枚举右端点
        sum += num 
        for sum >= target {
            ans = min(ans, right-left+1)
            sum -= nums[left]
            left++
        }
    }

    if ans <= n {
        return ans 
    }
    return 0 
}

func min(a, b int) int { if a < b { return a }; return b }
```

py: 

```python
class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        n = len(nums)
        left = 0
        ans = n + 1 
        s = 0  
        for right, num in enumerate(nums):  # 枚举右端点
            s += num 
            while s >= target:
                ans = min(ans, right-left+1)
                s -= nums[left] 
                left += 1

        return ans if ans <= n else 0 
```

## [713. 乘积小于 K 的子数组](https://leetcode.cn/problems/subarray-product-less-than-k/)

给你一个整数数组 `nums` 和一个整数 `k` ，请你返回子数组内所有元素的乘积严格小于 `k` 的连续子数组的数目。

```wiki
输入：nums = [10,5,2,6], k = 100
输出：8
解释：8 个乘积小于 100 的子数组分别为：[10]、[5]、[2],、[6]、[10,5]、[5,2]、[2,6]、[5,2,6]。
需要注意的是 [10,5,2] 并不是乘积小于 100 的子数组。
```

> 思路：方法同上，若元素的乘积>=k就把左端点右移，缩小子数组长度，直到乘积小于k。

go

```go
func numSubarrayProductLessThanK(nums []int, k int) int {
    if k <= 1 {
        return 0 
    }

    ans := 0 // 初始子数组数目
    prod := 1 // 初始乘积
    left := 0 
    for right, n := range nums {
        prod *= n 
        for prod >= k {
            prod /= nums[left]
            left++
        }
        ans += right-left+1
    }
    return ans 
}
```



python 

```python
class Solution:
    def numSubarrayProductLessThanK(self, nums: List[int], k: int) -> int:
        if k <= 1:
            return 0 
        
        ans = 0  # 初始子数组数目为0
        prod = 1  # 初始乘积为1
        left = 0 
        for right, num in enumerate(nums):
            prod *= num 
            while prod >= k:
                prod /= nums[left]
                left += 1 

            ans += right - left + 1  # 统计子数组数目

        return ans 
```

## [3. 无重复字符的最长子串]() ==重要！==

思路：双指针滑窗+hashmap

go

```go
func lengthOfLongestSubstring(s string) int {
    // freq := map[byte]int{} // key:byte, val:int
    freq := make([]byte, 128) // s 由英文字母、数字、符号和空格组成
    ans := 0 
    left := 0 
    for right := range s {
        freq[s[right]]++
        for freq[s[right]] > 1 {
            freq[s[left]]--
            left++
        }
        ans = max(ans, right-left+1) // 字符个数
    }
    return ans 
}

func max(a, b int) int { if a < b { return b }; return a }
```

时间复杂度：O(n)

空间复杂度：O(128) or O(len(set(s))) or O(1)，常数空间

## [1004. 最大连续1的个数 III](https://leetcode.cn/problems/max-consecutive-ones-iii/description/)

```go
func longestOnes(nums []int, k int) int {
    ans := 0 
    left := 0 
    for right, num := range nums {
        if num == 0 {
            k-- // 相当于翻转
        }

        for k < 0 { // 收缩窗口
            if nums[left] == 0 {
                k++
            }
            left++
        }
        
        ans = max(ans, right-left+1)
    }
    return ans 
}

func max(a, b int) int { if a < b { return b }; return a }
```

# 相向双指针

## [1. 两数之和]()

思路：hashmap

```go
func twoSum(nums []int, tar int) []int {
    m := map[int]int{} // key存元素,val存索引
    for i, num := range nums {
        if _, exist := m[tar-num]; exist {
            return []int{i, m[tar-num]}
        }
        m[num] = i 
    }  
    return []int{}
} 
```

## [167. 两数之和2-有序数组]()

注意题目条件：有序！！！直接使用相向双指针

```go
func twoSum(nums []int, target int) []int {
    left, right := 0, len(nums)-1
    for true {
        sum := nums[left] + nums[right]
        if sum == target {
            break 
        }

        if sum < target {
            left++
        } else { 
            right--
        }
    }
    return []int{left+1, right+1}
}
// 时间：O(n)-- 每次通过大小关系直接去掉了一个数，每次花费O(1)
```



## [15. 三数之和](https://leetcode.cn/problems/3sum/)

你返回所有和为 0 且不重复的三元组。

时间O(n^2)

```go
func threeSum(nums []int) [][]int {
    // 三元组的顺序并不重要---那就规定一个顺序: i < j < k 
    // 不可以包含重复的三元组---排序，去重
    sort.Ints(nums)
    ans := make([][]int, 0)
    n := len(nums)
    for i := 0; i < n-2; i++ { // n-2是为保证是三元组
        x := nums[i] 
        // 去重
        if i > 0 && nums[i-1] == x {
            continue 
        }
        // 优化1--x和最小的两个数加起来都大于0,那后面不会有等于0的情况了
        if x + nums[i+1] + nums[i+2] > 0 {
            break
        }
        // 优化2--x和最大的两个数加起来小于0,跳出本次循环，后面有可能等于0的情况
        if x + nums[n-2] + nums[n-1] < 0 {
            continue
        }

        // 转为【两数之和2】问题
        j := i + 1 
        k := n - 1 
        for j < k {
            sum := x + nums[j] + nums[k] 
            if sum < 0 {
                j++
            } else if sum > 0 {
                k-- 
            } else {
                tmp := []int{x, nums[j], nums[k]}
                ans = append(ans, tmp)
                j++
                k-- 
                // j k 也要去重
                for j < k && nums[j] == nums[j-1] { j++ }
                for j < k && nums[k] == nums[k+1] { k-- }
            }
        }
    }
    return ans
}
```
